# Combined Python Codebase
# Generated on: 2025-03-23 07:40:33.272180
# Source directory: /home/admin/Plus91Backoffice/plus91_management/app/frontend


================================================================================
# File: account.gs
================================================================================


function viewAccounts() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  try {
    // Log the start of creating/clearing the read-only sheet
    logAction(
      "Create Sheet",
      "View Accounts",
      "",
      "",
      "",
      "Started",
      "Attempting to create or clear the 'Account Details' sheet",
      "INFO"
    );

    // 1) Create or clear the "Account Details" sheet
    const sheetName = "Account Details";
    let sheet = ss.getSheetByName(sheetName);

    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
      logAction(
        "Create Sheet",
        sheetName,
        "",
        "",
        "",
        "Success",
        `Created new '${sheetName}' sheet`,
        "INFO"
      );
    } else {
      sheet.clear();
      logAction(
        "Clear Sheet",
        sheetName,
        "",
        "",
        "",
        "Success",
        `Cleared existing '${sheetName}' sheet`,
        "INFO"
      );
    }

    // 2) Add a read-only notice at the top (merge columns as needed)
    const totalColumns = 13; // Because we have 13 columns below
    sheet
      .getRange(1, 1, 1, totalColumns)
      .merge()
      .setValue("Account Details Sheet: [Read Only]")
      .setBackground("#a4c2f4")
      .setFontColor("#000000")
      .setFontWeight("bold")
      .setHorizontalAlignment("center");

    // 3) Create column headers in the second row
    const headers = [
      "Account ID",
      "Account Name",
      "Account Type",
      "Bracket Name",
      "Portfolio Name",
      "PF Value",
      "Cash Value",
      "Total Holdings",
      "Invested Amount",
      "Total TWRR",
      "Current Year TWRR",
      "CAGR",
      "Created At"
    ];

    sheet
      .getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#3c78d8")
      .setFontColor("#FFFFFF");

    sheet.setFrozenRows(2);

    // Set a uniform width for all columns so they are evenly spaced
    sheet.setColumnWidths(1, headers.length, 130);

    // 4) Fetch account data from the endpoint
    const endpoint = "http://15.207.59.232:8000/accounts/list";
    let accountData = [];

    try {
      logAction(
        "Fetch Data",
        "Accounts",
        "",
        "",
        "",
        "Started",
        "Fetching account data from " + endpoint,
        "INFO"
      );

      const response = UrlFetchApp.fetch(endpoint);
      const statusCode = response.getResponseCode();

      if (statusCode === 200) {
        const respObj = JSON.parse(response.getContentText());

        // If the response schema is { status: ..., data: [...] }:
        if (respObj && respObj.data) {
          accountData = respObj.data;
        }

        logAction(
          "Fetch Data",
          "Accounts",
          "",
          "",
          "",
          "Success",
          `Fetched ${accountData.length} accounts from ${endpoint}`,
          "INFO"
        );
      } else {
        logAction(
          "Fetch Data",
          "Accounts",
          "",
          "",
          "",
          "Failed",
          "Status code: " + statusCode,
          "ERROR"
        );
        ui.alert(`Failed to fetch account data. Status code: ${statusCode}`);
      }
    } catch (error) {
      logError("viewAccounts:FetchData", error);
      ui.alert("Error fetching account data: " + error.message);
    }

    // 5) Populate the sheet if we have data
    if (accountData.length > 0) {
      const rowData = accountData.map(acc => [
        acc.account_id || "",
        acc.account_name || "",
        acc.account_type || "",
        acc.bracket_name || "",
        acc.portfolio_name || "",
        acc.pf_value != null ? acc.pf_value : "",
        acc.cash_value != null ? acc.cash_value : "",
        acc.total_holdings != null ? acc.total_holdings : "",
        acc.invested_amt != null ? acc.invested_amt : "",
        acc.total_twrr != null ? acc.total_twrr : "",
        acc.current_yr_twrr != null ? acc.current_yr_twrr : "",
        acc.cagr != null ? acc.cagr : "",
        acc.created_at || ""
      ]);

      sheet
        .getRange(3, 1, rowData.length, headers.length)
        .setValues(rowData);

      logAction(
        "Populate Sheet",
        sheetName,
        "",
        "",
        "",
        "Success",
        `Populated ${rowData.length} rows with account data`,
        "INFO"
      );
    } else {
      logAction(
        "Populate Sheet",
        sheetName,
        "",
        "",
        "",
        "Success",
        "No account data found to display",
        "INFO"
      );
    }

    // 6) Color alternate rows (white for first row, #F8F8F8 for second, etc.)
    const startRow = 3; // first row of data
    const numRows = sheet.getLastRow() - (startRow - 1);
    for (let i = 0; i < numRows; i++) {
      const rowIndex = startRow + i;
      // even row index => #FFFFFF, odd => #F8F8F8
      if (i % 2 === 0) {
        sheet
          .getRange(rowIndex, 1, 1, headers.length)
          .setBackground("#FFFFFF");
      } else {
        sheet
          .getRange(rowIndex, 1, 1, headers.length)
          .setBackground("#F8F8F8");
      }
    }

    // 7) Make all data rows read-only by protecting them
    try {
      const protectionRange = sheet.getRange(
        startRow,
        1,
        sheet.getMaxRows() - 2,
        headers.length
      );
      const protection = protectionRange.protect();
      protection.setDescription("Protected range for read-only sheet");

      if (protection.canDomainEdit()) {
        protection.setDomainEdit(false);
      }

      // Remove existing editors to ensure it's fully read-only
      const editors = protection.getEditors();
      if (editors && editors.length > 0) {
        protection.removeEditors(editors);
      }

      // Setting protections for the entire sheet generally might be needed:
      // sheet.protect().setWarningOnly(true);
    } catch (protError) {
      logAction(
        "Set Protection",
        sheetName,
        "",
        "",
        "",
        "Failed",
        "Unable to protect sheet range. " + protError.message,
        "ERROR"
      );
    }

    // Notify user that the sheet is ready
    ui.alert(
      "Account Details Sheet Ready",
      "This is a read-only sheet showing all accounts.",
      ui.ButtonSet.OK
    );

    logAction(
      "Create Sheet",
      "View Accounts",
      "",
      "",
      "",
      "Completed",
      `'${sheetName}' sheet successfully populated`,
      "INFO"
    );

    sheet.activate();
  } catch (error) {
    // Log and notify major errors
    logError("viewAccounts", error);
    ui.alert(
      `Error creating or populating the '${sheetName}' sheet: ${error.message}`
    );
  }
}

function updateAccounts() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  try {
    logAction(
      "Create Sheet",
      "Update Accounts",
      "",
      "",
      "",
      "Started",
      "Attempting to create or clear the 'Update Accounts' sheet",
      "INFO"
    );

    // Create or clear the "Update Accounts" sheet
    let sheet = ss.getSheetByName("Update Accounts");
    if (!sheet) {
      sheet = ss.insertSheet("Update Accounts");
      logAction(
        "Create Sheet",
        "Update Accounts",
        "",
        "",
        "",
        "Success",
        "Created new 'Update Accounts' sheet",
        "INFO"
      );
    } else {
      sheet.clear();
      logAction(
        "Clear Sheet",
        "Update Accounts",
        "",
        "",
        "",
        "Success",
        "Cleared existing 'Update Accounts' sheet",
        "INFO"
      );
    }

    // Provide instructions in row 1
    sheet.getRange(1, 1, 1, 12)
      .merge()
      .setValue(
        "Instructions:\n" +
        "1) Check rows to update (Column A)\n" +
        "2) Single accounts can edit PF Value, Cash Value, Invested Amt, and TWRR fields.\n" +
        "3) Joint accounts can only edit TWRR fields.\n" +
        "4) 'Total Holdings' and 'Created At' are read-only.\n" +
        "When done, click 'Save Account Changes'."
      )
      .setBackground("#F4B084")
      .setFontColor("#000000")
      .setFontWeight("bold");

    // Define columns
    const headers = [
      "Select",             // A
      "Account ID",         // B
      "Account Name",       // C (for reference)
      "Account Type",       // D (single/joint)
      "PF Value",           // E
      "Cash Value",         // F
      "Invested Amt",       // G
      "Total TWRR",         // H
      "Current Yr TWRR",    // I
      "CAGR",               // J
      "Total Holdings",     // K (read-only)
      "Created At"          // L (read-only)
    ];
    sheet.getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#d67332")
      .setFontColor("#FFFFFF");

    sheet.setFrozenRows(2);
    sheet.setColumnWidths(1, headers.length, 140);

    // Add checkboxes in column A
    const checkboxRange = sheet.getRange(3, 1, 1000);
    const checkboxRule = SpreadsheetApp.newDataValidation().requireCheckbox().build();
    checkboxRange.setDataValidation(checkboxRule);

    // Fetch accounts from backend
    // e.g. GET /accounts/list => { status: "success", data: [ {account_id,...}, ... ] }
    // We'll parse 'data' property
    let accountData = [];
    try {
      const endpoint = "http://15.207.59.232:8000/accounts/list";
      const resp = UrlFetchApp.fetch(endpoint);
      const body = JSON.parse(resp.getContentText());
      accountData = body.data || [];
      logAction(
        "Fetch Data",
        "Accounts",
        "",
        "",
        "",
        "Success",
        `Fetched ${accountData.length} accounts`,
        "INFO"
      );
    } catch (err) {
      logError("updateAccounts:Fetch", err);
      ui.alert("Error fetching accounts: " + err.message);
    }

    // Populate
    if (accountData.length > 0) {
      const rowData = accountData.map(acc => [
        false, // checkbox
        acc.account_id || "",
        acc.account_name || "",
        acc.account_type || "",
        acc.pf_value != null ? acc.pf_value : "",
        acc.cash_value != null ? acc.cash_value : "",
        acc.invested_amt != null ? acc.invested_amt : "",
        acc.total_twrr != null ? acc.total_twrr : "",
        acc.current_yr_twrr != null ? acc.current_yr_twrr : "",
        acc.cagr != null ? acc.cagr : "",
        acc.total_holdings != null ? acc.total_holdings : "",
        acc.created_at || ""
      ]);
      sheet.getRange(3, 1, rowData.length, headers.length).setValues(rowData);
    }

    // Optionally protect columns K,L
    const readOnlyCols = [11, 12]; // col K=11, L=12
    readOnlyCols.forEach(col => {
      const rng = sheet.getRange(3, col, sheet.getMaxRows()-2);
      rng.setBackground("#F3F3F3");
      const prot = rng.protect().setDescription(`Protected col ${col} (TotalHoldings/CreatedAt)`);
      if (prot.canDomainEdit()) {
        prot.setDomainEdit(false);
      }
      const editors = prot.getEditors();
      if (editors && editors.length) {
        prot.removeEditors(editors);
      }
    });

    ui.alert(
      "Update Accounts Sheet Ready",
      "Select rows, edit fields for single/joint as allowed, then click 'Save Account Changes'.",
      ui.ButtonSet.OK
    );
    logAction(
      "Create Sheet",
      "Update Accounts",
      "",
      "",
      "",
      "Completed",
      "Sheet successfully populated",
      "INFO"
    );

    sheet.activate();
  } catch (err) {
    logError("updateAccounts", err);
    ui.alert("Error creating or populating 'Update Accounts' sheet: " + err.message);
  }
}

function updateAccountsSave() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetName = "Update Accounts";
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    SpreadsheetApp.getUi().alert("Sheet 'Update Accounts' not found.");
    logAction("Update Accounts", "Sheet", "", "", "", "Failed", "Sheet not found", "ERROR");
    return;
  }

  const lastRow = sheet.getLastRow();
  if (lastRow < 3) {
    ss.toast("No accounts found to update.", "Info", 3);
    return;
  }

  // We have 12 columns
  // A: checkbox
  // B: account_id
  // C: account_name (not used for update, only reference)
  // D: account_type
  // E: pf_value
  // F: cash_value
  // G: invested_amt
  // H: total_twrr
  // I: current_yr_twrr
  // J: cagr
  // K: total_holdings (read-only)
  // L: created_at (read-only)
  const numCols = 12;
  const dataRange = sheet.getRange(3, 1, lastRow - 2, numCols);
  const data = dataRange.getValues();

  const updates = [];

  data.forEach((row, idx) => {
    if (row[0] === true) {
      // parse row
      const accountId = row[1] ? row[1].toString().trim() : "";
      const accountName = row[2] || "";
      const accountType = row[3] ? row[3].toString().trim() : "";

      // parse numbers carefully
      const pfVal = row[4] !== "" ? parseFloat(row[4]) : undefined;
      const cashVal = row[5] !== "" ? parseFloat(row[5]) : undefined;
      const investedAmt = row[6] !== "" ? parseFloat(row[6]) : undefined;
      const totalTwrr = row[7] !== "" ? parseFloat(row[7]) : undefined;
      const currentYrTwrr = row[8] !== "" ? parseFloat(row[8]) : undefined;
      const cagr = row[9] !== "" ? parseFloat(row[9]) : undefined;

      const updatePayload = {
        account_id: accountId,
        account_type: accountType
      };

      if (!isNaN(pfVal)) updatePayload.pf_value = pfVal;
      if (!isNaN(cashVal)) updatePayload.cash_value = cashVal;
      if (!isNaN(investedAmt)) updatePayload.invested_amt = investedAmt;
      if (!isNaN(totalTwrr)) updatePayload.total_twrr = totalTwrr;
      if (!isNaN(currentYrTwrr)) updatePayload.current_yr_twrr = currentYrTwrr;
      if (!isNaN(cagr)) updatePayload.cagr = cagr;

      updates.push(updatePayload);

      logAction(
        "Validation",
        "Account",
        accountName,
        "",
        "",
        "Pending",
        `Row ${idx+3}: Updating ${accountType} => ID: ${accountId}`,
        "INFO"
      );
    }
  });

  if (updates.length === 0) {
    ss.toast("No rows selected for update.", "Info", 3);
    return;
  }

  logAction("Update Accounts", "Sheet", "", "", "", "Sending", 
            `Sending ${updates.length} account updates`, "INFO");

  // Call partial-success endpoint /accounts/update
  const url = "http://15.207.59.232:8000/accounts/update";
  const options = {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify(updates),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const code = response.getResponseCode();
    const text = response.getContentText();

    logAction(
      "Update Accounts",
      "API Response",
      "",
      "",
      "",
      code === 200 ? "Success" : "Failed",
      `Response: ${text}`,
      code === 200 ? "INFO" : "ERROR"
    );

    if (code !== 200) {
      SpreadsheetApp.getUi().alert(`Error updating accounts: ${text}`);
      return;
    }

    const result = JSON.parse(text); 
    // result => { total_rows, processed_rows, results: [ {row_index, status, detail, account_id}, ... ] }

    let failCount = 0;
    let successCount = 0;
    let failMsgs = [];

    result.results.forEach(r => {
      if (r.status === "success") {
        successCount++;
        logAction("Update Accounts", "Account", r.account_id, "", "", 
                  "Success", `Row ${r.row_index}: ${r.detail}`, "INFO");
      } else {
        failCount++;
        failMsgs.push(`Row ${r.row_index}: ${r.detail}`);
        logAction("Update Accounts", "Account", r.account_id, "", "", 
                  "Failed", `Row ${r.row_index}: ${r.detail}`, "ERROR");
      }
    });

    const msg = `Bulk Update Completed:
      Total Rows: ${result.total_rows}
      Success: ${result.processed_rows}
      Failures: ${failCount}
      ${failCount > 0 ? "Errors:\n" + failMsgs.join("\n") : ""}`;

    SpreadsheetApp.getUi().alert(msg);
    ss.toast("Account updates completed. Check Logs for details.", "Success", 5);

  } catch (err) {
    logError("updateAccountsSave", err, { updates });
    ss.toast("Account update failed: " + err.message, "Error", 5);
  }
}


function manageJointAccounts() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  try {
    // Log the beginning of the sheet setup
    logAction(
      "Create Sheet",
      "Manage Joint Accounts",
      "",
      "",
      "",
      "Started",
      "Attempting to create or clear the 'Manage Joint Accounts' sheet",
      "INFO"
    );

    // Create or clear the 'Manage Joint Accounts' sheet
    let sheet = ss.getSheetByName("Manage Joint Accounts");
    if (!sheet) {
      sheet = ss.insertSheet("Manage Joint Accounts");
      logAction(
        "Create Sheet",
        "Manage Joint Accounts",
        "",
        "",
        "",
        "Success",
        "Created new 'Manage Joint Accounts' sheet",
        "INFO"
      );
    } else {
      sheet.clear();
      logAction(
        "Clear Sheet",
        "Manage Joint Accounts",
        "",
        "",
        "",
        "Success",
        "Cleared existing 'Manage Joint Accounts' sheet",
        "INFO"
      );
    }

    // Add a header cell with instructions
    sheet
      .getRange(1, 1, 1, 5)
      .merge()
      .setValue(
        "Instructions:\n" +
        "1. Specify the action (create, update, or delete) in the dropdown.\n" +
        "2. When updating or deleting, include a valid Joint Account ID. If creating, leave ID blank.\n" +
        "3. 'Linked Single Accounts' should be comma-separated IDs.\n" +
        "4. After filling in rows, click 'Save Joint Accounts' to send changes to the server."
      )
      .setBackground("#F4B084")
      .setFontColor("#000000")
      .setFontWeight("bold");

    // Define table headers
    const headers = [
      "Action",                 // Column A
      "Joint Account ID",       // Column B
      "Account Name",           // Column C
      "Linked Single Accounts", // Column D
      "Status/Notes"            // Column E
    ];
    sheet
      .getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#000000")
      .setFontColor("#ffffff");

    // Freeze the header row
    sheet.setFrozenRows(2);

    // Adjust column widths
    sheet.setColumnWidths(1, headers.length, 220);

    // Create a dropdown in column A (Action) for 100 rows, allowing only "create", "update", or "delete"
    const actionRange = sheet.getRange(3, 1, 100); // from row 3 to row 102, column A
    const actionRule = SpreadsheetApp.newDataValidation()
      .requireValueInList(["create", "update", "delete"], true)
      .setAllowInvalid(false)
      .build();
    actionRange.setDataValidation(actionRule);

    // Log that the sheet setup is complete
    logAction(
      "Create Sheet",
      "Manage Joint Accounts",
      "",
      "",
      "",
      "Completed",
      "'Manage Joint Accounts' sheet successfully set up",
      "INFO"
    );

    // Bring the sheet into focus
    sheet.activate();
  } catch (error) {
    // Log errors and notify the user
    logError("manageJointAccounts", error);
    ui.alert(
      "Error creating or populating the 'Manage Joint Accounts' sheet: " + error.message
    );
  }
}

function saveJointAccountChanges() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();
  const sheet = ss.getSheetByName("Manage Joint Accounts");
  if (!sheet) {
    ui.alert("Sheet 'Manage Joint Accounts' not found.");
    logAction(
      "Save Changes",
      "Manage Joint Accounts",
      "",
      "",
      "",
      "Failed",
      "No 'Manage Joint Accounts' sheet found",
      "ERROR"
    );
    return;
  }

  // Determine how many rows have data
  const lastRow = sheet.getLastRow();
  if (lastRow < 3) {
    // No data rows after header row (which ends at row 2)
    ui.alert("No rows found to process.");
    return;
  }

  // Read data starting from row 3 (row 1: instructions, row 2: headers)
  const dataRange = sheet.getRange(3, 1, lastRow - 2, 5);
  const data = dataRange.getValues();

  // Will keep track of how many total actions we attempt
  let totalActions = 0;
  // We'll store any error messages in an array to present to the user
  const errors = [];

  // Iterate over each row, sending the appropriate request
  data.forEach((row, idx) => {
    const action = (row[0] || "").toString().trim().toLowerCase();
    const jointAccountId = (row[1] || "").toString().trim();
    const accountName = (row[2] || "").toString().trim();
    const linkedAccountsRaw = (row[3] || "").toString().trim();

    // Skip empty rows (no action)
    if (!action) {
      return;
    }

    // Parse comma-separated single accounts into an array
    let linkedSingleAccounts = [];
    if (linkedAccountsRaw) {
      linkedSingleAccounts = linkedAccountsRaw
        .split(",")
        .map(item => item.trim())
        .filter(item => !!item);
    }

    // We use different endpoints based on the action
    let url = "";
    let method = "";
    let payloadObj = {};

    if (action === "create") {
      // POST /joint-accounts
      url = "http://15.207.59.232:8000/joint-accounts";
      method = "post";
      payloadObj = {
        joint_account_name: accountName,
        single_account_ids: linkedSingleAccounts
      };
    } else if (action === "update") {
      // PUT /joint-accounts/{joint_account_id}
      if (!jointAccountId) {
        errors.push(
          `Row ${idx + 3}: 'update' requires a valid Joint Account ID. Skipping.`
        );
        return;
      }
      url = `http://15.207.59.232:8000/joint-accounts/${jointAccountId}`;
      method = "put";
      payloadObj = {
        joint_account_name: accountName,
        single_account_ids: linkedSingleAccounts
      };
    } else if (action === "delete") {
      // DELETE /joint-accounts/{joint_account_id}
      if (!jointAccountId) {
        errors.push(
          `Row ${idx + 3}: 'delete' requires a valid Joint Account ID. Skipping.`
        );
        return;
      }
      url = `http://15.207.59.232:8000/joint-accounts/${jointAccountId}`;
      method = "delete";
      // Usually, delete requests can be empty or minimal
      // but if the backend expects a body, add it here
    } else {
      // Unrecognized action
      errors.push(`Row ${idx + 3}: Unknown action '${action}'. Skipping.`);
      return;
    }

    // We'll proceed if we have a valid method
    const options = {
      method: method,
      contentType: "application/json",
      muteHttpExceptions: true
    };

    // DELETE typically doesn't need a payload. If it's needed, uncomment:
    if (method !== "delete") {
      options.payload = JSON.stringify(payloadObj);
    }

    // Attempt the request
    try {
      const response = UrlFetchApp.fetch(url, options);
      const code = response.getResponseCode();
      const text = response.getContentText();

      totalActions += 1;
      if (code >= 200 && code < 300) {
        logAction(
          method.toUpperCase(),
          "Manage Joint Accounts",
          jointAccountId,
          accountName,
          linkedAccountsRaw,
          "Success",
          `Server responded with: ${text}`,
          "INFO"
        );
      } else {
        // Log error
        const msg = `Failed Action: ${action.toUpperCase()}, Row ${idx + 3} => Code: ${code}, Response: ${text}`;
        logAction(
          method.toUpperCase(),
          "Manage Joint Accounts",
          jointAccountId,
          accountName,
          linkedAccountsRaw,
          "Failed",
          msg,
          "ERROR"
        );
        errors.push(msg);
      }
    } catch (error) {
      const msg = `Error in sending '${action.toUpperCase()}' for Row ${
        idx + 3
      }: ${error.toString()}`;
      logError("saveJointAccountChanges", error);
      errors.push(msg);
    }
  });

  // Summarize the results to the user
  logAction(
    "Save Changes",
    "Manage Joint Accounts",
    "",
    "",
    "",
    "Completed",
    `Completed ${totalActions} actions with ${errors.length} errors`,
    "INFO"
  );

  if (errors.length > 0) {
    ui.alert(
      `Finished processing with errors:\n\n${errors.join("\n")}`
    );
  } else if (totalActions > 0) {
    ui.alert(`Successfully processed ${totalActions} joint account actions!`);
  } else {
    // No actions processed
    ui.alert("No actions were processed.");
  }
}


================================================================================
# File: brokerDistributorsHTML.html
================================================================================

<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: 'Google Sans', Roboto, Arial, sans-serif;
      padding: 10px;
      color: #202124;
      font-size: 14px;
    }
    h3 {
      margin-top: 0;
      color: #188038;
      border-bottom: 2px solid #188038;
      padding-bottom: 8px;
      font-size: 16px;
    }
    h4 {
      color: #188038;
      margin-top: 15px;
      font-size: 14px;
      font-weight: 500;
    }
    select, input[type="text"] {
      width: 100%;
      margin-bottom: 10px;
      padding: 8px;
      border: 1px solid #dadce0;
      border-radius: 4px;
      box-sizing: border-box;
      font-size: 14px;
      color: #202124;
    }
    button {
      background-color: #188038;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 5px;
      transition: background-color 0.2s;
      font-size: 14px;
    }
    button:hover {
      background-color: #137333;
    }
    .items-list {
      border: 1px solid #dadce0;
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 10px;
      padding: 5px;
      background: #fff;
    }
    .item {
      padding: 6px 8px;
      border-bottom: 1px solid #dadce0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .remove-btn {
      background-color: #ea4335;
      padding: 4px 8px;
      border: none;
      color: white;
      border-radius: 3px;
      font-size: 12px;
      cursor: pointer;
    }
    .remove-btn:hover {
      background-color: #d93025;
    }
  </style>
</head>
<body>
  <h3>Manage Brokers and Distributors</h3>
  <label for="sectionSelect">Select Category:</label>
  <select id="sectionSelect">
    <option value="Brokers">Brokers</option>
    <option value="Distributors">Distributors</option>
  </select>
  <div id="itemsList" class="items-list">
    <div>Loading...</div>
  </div>
  
  <div id="managementSection">
    <h4>Add New Item</h4>
    <input type="text" id="newItemInput" placeholder="Enter new item name" />
    <button id="addItemBtn" onclick="addNewItem()">Add</button>
    
    <h4>Update Item</h4>
    <input type="text" id="oldItemInput" placeholder="Old item name" />
    <input type="text" id="updatedItemInput" placeholder="New item name" />
    <button id="updateItemBtn" onclick="updateItem()">Update</button>
  </div>
  
  <script>
    const BASE_URL = "http://15.207.59.232:8000/";
    const sectionSelect = document.getElementById('sectionSelect');
    const itemsList = document.getElementById('itemsList');
    
    function showLoading() {
      itemsList.innerHTML = "<div>Loading...</div>";
    }
    
    function loadItems() {
      const section = sectionSelect.value;
      showLoading();
      google.script.run.withSuccessHandler(function(items) {
        populateItems(items);
      }).withFailureHandler(function(err) {
        alert("Error: " + err.message);
      }).getItemsFromBackend(section);
    }
    
    function populateItems(items) {
      itemsList.innerHTML = "";
      if (!items || items.length === 0) {
        itemsList.innerHTML = "<div>No items found.</div>";
        return;
      }
      items.forEach(function(item) {
        let div = document.createElement("div");
        div.className = "item";
        let span = document.createElement("span");
        span.textContent = item;
        let removeBtn = document.createElement("button");
        removeBtn.className = "remove-btn";
        removeBtn.textContent = "Remove";
        removeBtn.onclick = function() {
          if (confirm("Are you sure you want to remove " + item + "?")) {
            deleteItemFromBackend(sectionSelect.value, item);
          }
        };
        div.appendChild(span);
        div.appendChild(removeBtn);
        itemsList.appendChild(div);
      });
    }
    
    function addNewItem() {
      const section = sectionSelect.value;
      const newItem = document.getElementById("newItemInput").value.trim();
      if (!newItem) {
        alert("Please enter a value.");
        return;
      }
      google.script.run.withSuccessHandler(loadItems)
         .withFailureHandler(function(err) { alert("Error: " + err.message); })
         .addNewItemToBackend(section, newItem);
    }
    
    function updateItem() {
      const section = sectionSelect.value;
      const oldItem = document.getElementById("oldItemInput").value.trim();
      const newItem = document.getElementById("updatedItemInput").value.trim();
      if (!oldItem || !newItem) {
        alert("Please fill both fields.");
        return;
      }
      google.script.run.withSuccessHandler(loadItems)
         .withFailureHandler(function(err) { alert("Error: " + err.message); })
         .updateItemInBackend(section, oldItem, newItem);
    }
    
    function deleteItemFromBackend(section, item) {
      google.script.run.withSuccessHandler(loadItems)
         .withFailureHandler(function(err) { alert("Error: " + err.message); })
         .deleteItemFromBackend(section, item);
    }
    
    sectionSelect.onchange = loadItems;
    loadItems();
  </script>
</body>
</html>


================================================================================
# File: logger.gs
================================================================================

/**
 * Sets up the logging system in the "Logs" sheet.
 */
function setupLoggingSystem() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let logSheet = ss.getSheetByName("Logs");
  if (!logSheet) {
    logSheet = ss.insertSheet("Logs");

    // Set up headers
    const headers = [
      "Timestamp", "Level", "Action Type", "Entity Type",
      "Name", "PAN", "Broker", "Status", "Details"
    ];

    logSheet.appendRow(headers);

    // Format header row
    const headerRange = logSheet.getRange(1, 1, 1, headers.length);
    headerRange.setBackground("#d9ead3")
      .setFontWeight("bold")
      .setWrap(true)
      .setHorizontalAlignment("center");

    // Set column widths
    logSheet.setColumnWidths(1, headers.length, 150);
    logSheet.setColumnWidth(1, 180);  // Timestamp
    logSheet.setColumnWidth(9, 300);  // Details

    // Freeze header row and add filters
    logSheet.setFrozenRows(1);
    headerRange.createFilter();
  }
  return logSheet;
}

/**
 * Logs a general action to the "Logs" sheet.
 */
function logAction(actionType, entityType, name, pan, broker, status, details, level = "INFO") {
  const logSheet = setupLoggingSystem();

  const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");

  const newRow = [
    timestamp,
    level,
    actionType,
    entityType,
    name || "",
    pan || "",
    broker || "",
    status,
    details || ""
  ];

  const lastRow = logSheet.getLastRow() + 1;
  const range = logSheet.getRange(lastRow, 1, 1, newRow.length);
  range.setValues([newRow]);

  // Apply color coding based on log level
  const levelCell = logSheet.getRange(lastRow, 2);
  switch (level) {
    case "ERROR":
      levelCell.setBackground("#f4cccc"); // light red
      range.setFontColor("#990000");
      break;
    case "WARNING":
      levelCell.setBackground("#fff2cc"); // light yellow
      break;
    case "INFO":
      levelCell.setBackground("#d9ead3"); // light green
      break;
    case "DEBUG":
      levelCell.setBackground("#cfe2f3"); // light blue
      break;
  }
}

/**
 * Logs errors with detailed context.
 */
function logError(functionName, error, additionalInfo = {}) {
  const errorDetails = {
    function: functionName,
    message: error.message,
    stack: error.stack,
    ...additionalInfo
  };

  logAction(
    "ERROR",
    "System",
    functionName,
    "",
    "",
    "Failed",
    JSON.stringify(errorDetails, null, 2),
    "ERROR"
  );
}

/**
 * Handles and logs API responses, including payloads and responses.
 */
function handleApiResponse(response, operation, payload = null) {
  try {
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();

    // Log API Request Payload
    if (payload) {
      logAction(
        operation,
        "API Request",
        "",
        "",
        "",
        "Sent",
        `Payload: ${JSON.stringify(payload)}`,
        "INFO"
      );
    }

    // Handle API Errors
    if (responseCode !== 200) {
      logAction(
        operation,
        "API Response",
        "",
        "",
        "",
        "Failed",
        `Error (${responseCode}): ${responseText}`,
        "ERROR"
      );
      throw new Error(`API Error: ${responseText}`);
    }

    // Log Successful Response
    logAction(
      operation,
      "API Response",
      "",
      "",
      "",
      "Success",
      `Response: ${responseText}`,
      "INFO"
    );

    return JSON.parse(responseText);
  } catch (error) {
    logError(operation, error);
    throw error;
  }
}

/**
 * Cleans up the "Logs" sheet by keeping only the last 1000 logs.
 */
function cleanupLogs() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const logSheet = ss.getSheetByName("Logs");
  if (!logSheet) return;

  const MAX_LOGS = 1000;
  const lastRow = logSheet.getLastRow();

  if (lastRow > MAX_LOGS + 1) { // +1 for header row
    logSheet.deleteRows(2, lastRow - MAX_LOGS - 1);
  }

  // Log the cleanup
  logAction(
    "System Maintenance",
    "Logs",
    "",
    "",
    "",
    "Cleanup",
    `Log cleanup performed. Keeping last ${MAX_LOGS} entries.`,
    "INFO"
  );
}

/**
 * Sets up a daily trigger to clean up logs.
 */
function createLogCleanupTrigger() {
  // Delete existing triggers
  ScriptApp.getProjectTriggers().forEach(trigger => {
    if (trigger.getHandlerFunction() === 'cleanupLogs') {
      ScriptApp.deleteTrigger(trigger);
    }
  });

  // Create new daily trigger
  ScriptApp.newTrigger('cleanupLogs')
    .timeBased()
    .everyDays(1)
    .atHour(1)
    .create();
}



================================================================================
# File: __init__.py
================================================================================



================================================================================
# File: manualInputs.gs
================================================================================

function setupActualPortfolioSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();
  const sheetName = "Actual Portfolio";
  let sheet = ss.getSheetByName(sheetName);

  try {
    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
    } else {
      sheet.clear();
    }

    // Instructions
    sheet
      .getRange(1, 1, 1, 4)
      .merge()
      .setValue("Instructions: Enter data for single accounts only. Use YYYY-MM-DD format for month-end dates.")
      .setBackground("#AFE1AF")
      .setFontColor("#000000")
      .setFontWeight("bold");

    // Headers
    const headers = ["Account ID", "Trading Symbol", "Quantity", "Date"];
    sheet
      .getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#379d37")
      .setFontColor("#FFFFFF");
    sheet.setFrozenRows(2);
    sheet.setColumnWidths(1, headers.length, 150);

    // Data Validation
    const quantityRange = sheet.getRange(3, 3, 1000); // Column C
    const quantityRule = SpreadsheetApp.newDataValidation()
      .requireNumberGreaterThanOrEqualTo(0)
      .setAllowInvalid(false)
      .build();
    quantityRange.setDataValidation(quantityRule);

    const dateRange = sheet.getRange(3, 4, 1000); // Column D
    const dateRule = SpreadsheetApp.newDataValidation()
      .requireDate()
      .setAllowInvalid(false)
      .build();
    dateRange.setDataValidation(dateRule);

    ui.alert("Actual Portfolio sheet is ready. Fill in the data and use 'Save Actual Portfolio' when done.");
    sheet.activate();
  } catch (error) {
    logError("setupActualPortfolioSheet", error);
    ui.alert("Error setting up Actual Portfolio sheet: " + error.message);
  }
}

function setupCashflowsSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();
  const sheetName = "Cashflows";
  let sheet = ss.getSheetByName(sheetName);

  try {
    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
    } else {
      sheet.clear();
    }

    // Instructions
    sheet
      .getRange(1, 1, 1, 4)
      .merge()
      .setValue("Instructions: Enter data for single accounts only. Use YYYY-MM-DD format. Cashflow: positive for inflow, negative for outflow.")
      .setBackground("#AFE1AF")
      .setFontColor("#000000")
      .setFontWeight("bold");

    // Headers
    const headers = ["Account ID", "Date", "Cashflow", "Tag"];
    sheet
      .getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#379d37")
      .setFontColor("#FFFFFF");
    sheet.setFrozenRows(2);
    sheet.setColumnWidths(1, headers.length, 150);

    // Data Validation
    const dateRange = sheet.getRange(3, 2, 1000); // Column B
    const dateRule = SpreadsheetApp.newDataValidation()
      .requireDate()
      .setAllowInvalid(false)
      .build();
    dateRange.setDataValidation(dateRule);

    const cashflowRange = sheet.getRange(3, 3, 1000); // Column C
    const cashflowRule = SpreadsheetApp.newDataValidation()
      .requireNumber()
      .setAllowInvalid(false)
      .build();
    cashflowRange.setDataValidation(cashflowRule);

    ui.alert("Cashflows sheet is ready. Fill in the data and use 'Save Cashflows' when done.");
    sheet.activate();
  } catch (error) {
    logError("setupCashflowsSheet", error);
    ui.alert("Error setting up Cashflows sheet: " + error.message);
  }
}

function setupExceptionsSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();
  const sheetName = "Exceptions";
  let sheet = ss.getSheetByName(sheetName);

  try {
    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
    } else {
      sheet.clear();
    }

    // Instructions
    sheet
      .getRange(1, 1, 1, 2)
      .merge()
      .setValue("Instructions: Enter data for single accounts only. List stocks to ignore in reconciliation.")
      .setBackground("#AFE1AF")
      .setFontColor("#000000")
      .setFontWeight("bold");

    // Headers
    const headers = ["Account ID", "Trading Symbol"];
    sheet
      .getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#379d37")
      .setFontColor("#FFFFFF");
    sheet.setFrozenRows(2);
    sheet.setColumnWidths(1, headers.length, 150);

    ui.alert("Exceptions sheet is ready. Fill in the data and use 'Save Exceptions' when done.");
    sheet.activate();
  } catch (error) {
    logError("setupExceptionsSheet", error);
    ui.alert("Error setting up Exceptions sheet: " + error.message);
  }
}



function saveCashflows() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();
  const sheet = ss.getSheetByName("Cashflows");

  if (!sheet) {
    ui.alert("Cashflows sheet not found.");
    return;
  }

  try {
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    const dataRows = values.slice(2);

    const data = dataRows
      .filter(row => row.some(cell => cell !== ""))
      .map(row => ({
        account_id: row[0],
        event_date: row[1],
        cashflow: row[2],
        tag: row[3]
      }));

    // Validation
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      if (!row.account_id || !row.event_date || row.cashflow === "" || !row.tag) {
        ui.alert(`Row ${i + 3}: All fields are required.`);
        return;
      }
      if (typeof row.cashflow !== "number" || isNaN(row.cashflow)) {
        ui.alert(`Row ${i + 3}: Cashflow must be a number.`);
        return;
      }
      if (!isValidDate(row.event_date)) {
        ui.alert(`Row ${i + 3}: Date must be a valid date in YYYY-MM-DD format.`);
        return;
      }
    }

    if (data.length === 0) {
      ui.alert("No data to save.");
      return;
    }

    // Send to API
    const endpoint = "https://your-api.com/manual/cashflows";
    const options = {
      method: "post",
      contentType: "application/json",
      payload: JSON.stringify(data),
      headers: { "Authorization": "Bearer " + ScriptApp.getOAuthToken() }
    };

    const response = UrlFetchApp.fetch(endpoint, options);
    handleApiResponse(response, "Save Cashflows", data);
    ui.alert("Cashflows saved successfully!");
  } catch (error) {
    logError("saveCashflows", error);
    ui.alert("Error saving Cashflows: " + error.message);
  }
}

function saveExceptions() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();
  const sheet = ss.getSheetByName("Exceptions");

  if (!sheet) {
    ui.alert("Exceptions sheet not found.");
    return;
  }

  try {
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    const dataRows = values.slice(2);

    const data = dataRows
      .filter(row => row.some(cell => cell !== ""))
      .map(row => ({
        account_id: row[0],
        trading_symbol: row[1]
      }));

    // Validation
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      if (!row.account_id || !row.trading_symbol) {
        ui.alert(`Row ${i + 3}: All fields are required.`);
        return;
      }
    }

    if (data.length === 0) {
      ui.alert("No data to save.");
      return;
    }

    // Send to API
    const endpoint = "https://your-api.com/manual/exceptions";
    const options = {
      method: "post",
      contentType: "application/json",
      payload: JSON.stringify(data),
      headers: { "Authorization": "Bearer " + ScriptApp.getOAuthToken() }
    };

    const response = UrlFetchApp.fetch(endpoint, options);
    handleApiResponse(response, "Save Exceptions", data);
    ui.alert("Exceptions saved successfully!");
  } catch (error) {
    logError("saveExceptions", error);
    ui.alert("Error saving Exceptions: " + error.message);
  }
}

function saveCashflows() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();
  const sheet = ss.getSheetByName("Cashflows Input");

  if (!sheet) {
    ui.alert("Cashflows sheet not found.");
    return;
  }

  try {
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    const dataRows = values.slice(2);

    const data = dataRows
      .filter(row => row.some(cell => cell !== ""))
      .map(row => ({
        owner_type: row[0],
        account_id: row[1],
        event_date: row[2],
        cashflow: row[3],
        tag: row[4]
      }));

    // Validation
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      if (!row.owner_type || !row.account_id || !row.event_date || row.cashflow === "" || !row.tag) {
        ui.alert(`Row ${i + 3}: All fields are required.`);
        return;
      }
      if (!["single", "joint"].includes(row.owner_type)) {
        ui.alert(`Row ${i + 3}: Owner Type must be 'single' or 'joint'.`);
        return;
      }
      if (typeof row.cashflow !== "number" || isNaN(row.cashflow)) {
        ui.alert(`Row ${i + 3}: Cashflow must be a number.`);
        return;
      }
      if (!isValidDate(row.event_date)) {
        ui.alert(`Row ${i + 3}: Date must be a valid date in YYYY-MM-DD format.`);
        return;
      }
    }

    if (data.length === 0) {
      ui.alert("No data to save.");
      return;
    }

    // Send to API
    const endpoint = "https://your-api.com/manual/cashflows"; // Replace with actual endpoint
    const options = {
      method: "post",
      contentType: "application/json",
      payload: JSON.stringify(data),
      headers: { "Authorization": "Bearer " + ScriptApp.getOAuthToken() }
    };

    const response = UrlFetchApp.fetch(endpoint, options);
    handleApiResponse(response, "Save Cashflows", data);
    ui.alert("Cashflows saved successfully!");
  } catch (error) {
    logError("saveCashflows", error);
    ui.alert("Error saving Cashflows: " + error.message);
  }
}

function isValidDate(dateStr) {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return false;
  const [year, month, day] = dateStr.split("-").map(Number);
  const date = new Date(year, month - 1, day);
  return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
}

function isValidMonthEndDate(dateStr) {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return false;
  const [year, month, day] = dateStr.split("-").map(Number);
  const date = new Date(year, month - 1, day);
  const lastDay = new Date(year, month, 0).getDate();
  return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === lastDay;
}

================================================================================
# File: portfolio.gs
================================================================================

function openStandardPortfolioSheet() {
  portfolioId = 1 // Standard Portfolio
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheetName = "Standard Portfolio";
  let sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
  }
  sheet.clear();
  const url = "http://15.207.59.232:8000/portfolios/" + portfolioId + "/structure";
  const options = { muteHttpExceptions: true };
  const resp = UrlFetchApp.fetch(url, options);
  if (resp.getResponseCode() != 200) {
    SpreadsheetApp.getUi().alert("Error fetching portfolio structure: " + resp.getContentText());
    return;
  }
  const data = JSON.parse(resp.getContentText());
  renderBracketBasketSheet(sheet, data);
}

function renderBracketBasketSheet(sheet, data) {
  // Write JSON output for debugging
  // var sheet1 = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Standard Portfolio");
  // sheet1.getRange("F50").setValue(JSON.stringify(data, null, 2));

  // TITLE: Basket & Bracket Allocation
  let totalColumns = 14;
  let titleRange = sheet.getRange(1, 1, 1, totalColumns);
  titleRange.merge();
  titleRange.setBackground("#2E2E2E");
  titleRange.setFontColor("#FFFFFF");
  titleRange.setFontWeight("bold");
  titleRange.setHorizontalAlignment("center");
  titleRange.setValue("Basket & Bracket Allocation");

  // INSTRUCTIONS FOR BASKETS AND BRACKETS
  let notesRow = 2;
  let notesRange = sheet.getRange(notesRow, 1, 1, totalColumns);
  notesRange.merge();
  notesRange.setBackground("#000000");
  notesRange.setFontColor("#FFFFFF");
  notesRange.setFontWeight("bold");
  notesRange.setVerticalAlignment("middle");
  let notesText = `*** Add Baskets and Brackets to the next of the rows and columns respectively. ***

  NOTES:

  1. Addition of a Text below the last row of Bracket cell and Text on right side of the Basket cell will create a new bracket and basket respectively with 0% Allocation if no values are added.
  2. If the name of the bracket or basket is left empty during creation, it will be named "Bracket_1", "Basket_2". Naming the Brackets and Baskets is highly recommended.
  3. Deleting all the values from a row with the name of Bracket will delete that Bracket! Same goes for Baskets for columns.`;
  notesRange.setValue(notesText);

  // HEADER ROW FOR BRACKETS AND BASKETS
  let rowOffset = 4;
  let headerRange = sheet.getRange(rowOffset, 1, 1, totalColumns);
  headerRange.setFontWeight("bold");

  // Set headers for bracket section
  let headers = ["Bracket Name", "Min Amount", "Max Amount"];
  for (let i = 0; i < headers.length; i++) {
    let cell = sheet.getRange(rowOffset, i + 1);
    cell.setValue(headers[i]);
    cell.setBackground("#91B9F9");
    cell.setFontWeight("bold");
    cell.setHorizontalAlignment("center");
  }

  // Set headers for basket section (basket names and their IDs in a hidden row)
  let basketStartCol = 4;
  // Write basket names in header row and their IDs in row 4 (hidden)
  for (let i = 0; i < data.baskets.length; i++) {
    let col = basketStartCol + i;
    let basketCell = sheet.getRange(rowOffset, col);
    basketCell.setValue(data.baskets[i].basket_name);
    basketCell.setBackground("#91B9F9");
    basketCell.setFontWeight("bold");
    basketCell.setHorizontalAlignment("center");
    // Write basket_id into row 1000, then hide row 1000 later if desired.
    let idCell = sheet.getRange(1000, col);
    idCell.setValue(data.baskets[i].basket_id);
    idCell.setFontSize(1);
    idCell.setFontColor("#FFFFFF");
  }

  // Write bracket rows (including bracket IDs in a hidden column)
  let rowStart = rowOffset + 1;
  for (let r = 0; r < data.brackets.length; r++) {
    let bracketRow = rowStart + r;
    sheet.getRange(bracketRow, 1).setValue(data.brackets[r].bracket_name).setBackground("#BCD4FC").setFontWeight("bold");
    sheet.getRange(bracketRow, 2).setValue(data.brackets[r].min_amount).setBackground("#BCD4FC").setFontWeight("bold");
    sheet.getRange(bracketRow, 3).setValue(data.brackets[r].max_amount).setBackground("#BCD4FC").setFontWeight("bold");
    sheet.getRange(bracketRow, 1, 1, 3).setHorizontalAlignment("center");
    // Write bracket_id in hidden column 50
    sheet.getRange(bracketRow, 50).setValue(data.brackets[r].bracket_id).setFontColor("#FFFFFF");
  }

  // Populate Basket Allocations using bracket_id and basket_id as key
  let bracketsArr = data.brackets;
  let basketsArr = data.baskets;
  let allocations = data.allocations;
  for (let r = 0; r < bracketsArr.length; r++) {
    for (let c = 0; c < basketsArr.length; c++) {
      let bracketId = bracketsArr[r].bracket_id;
      let basketId = basketsArr[c].basket_id;
      let key = `${bracketId},${basketId}`;
      let allocationValue = allocations[key] || 0;
      let targetCell = sheet.getRange(rowStart + r, basketStartCol + c);
      targetCell.setValue(allocationValue);
      targetCell.setHorizontalAlignment("center");
    }
  }

  // Leave 6 blank rows after the allocation table
  let secondTitleRow = rowStart + data.brackets.length + 6;
  let secondTitleRange = sheet.getRange(secondTitleRow, 1, 1, totalColumns);
  secondTitleRange.merge();
  secondTitleRange.setBackground("#800000");
  secondTitleRange.setFontColor("#FFFFFF");
  secondTitleRange.setFontWeight("bold");
  secondTitleRange.setHorizontalAlignment("center");
  secondTitleRange.setValue("Do not fill Brackets beyond this buffer line, please save the current additions first, reload the sheet and then add the remaining Baskets.");

  // Two blank merged rows with light maroon red background
  let blankRow1 = secondTitleRow + 1;
  let blankRow2 = blankRow1 + 1;
  sheet.getRange(blankRow1, 1, 1, totalColumns).merge().setBackground("#C06060");
  sheet.getRange(blankRow2, 1, 1, totalColumns).merge().setBackground("#C06060");

  // Basket & Stock Multiplier Allocation title row
  let multiplierTitleRow = blankRow2 + 1;
  let multiplierTitleRange = sheet.getRange(multiplierTitleRow, 1, 1, totalColumns);
  multiplierTitleRange.merge();
  multiplierTitleRange.setBackground("#2E2E2E");
  multiplierTitleRange.setFontColor("#FFFFFF");
  multiplierTitleRange.setFontWeight("bold");
  multiplierTitleRange.setHorizontalAlignment("center");
  multiplierTitleRange.setValue("Basket & Stock Multiplier Allocation");

  // Instructions row for basket stocks
  let instructionsRow = multiplierTitleRow + 1;
  let instructionsRange = sheet.getRange(instructionsRow, 1, 1, totalColumns);
  instructionsRange.merge();
  instructionsRange.setBackground("#000000");
  instructionsRange.setFontColor("#FFFFFF");
  instructionsRange.setFontWeight("bold");
  instructionsRange.setVerticalAlignment("middle");
  let instructionsText = `*** Strict Instructions to follow! ***

  1. Use Trading symbols from Dhan Master file.
  2. Keep a space of one** column in between 2 tables as already formatted below.
  3. Basket name must** match with the name of the basket in 'Bracket & Basket Allocation' table.`;
  instructionsRange.setValue(instructionsText);

  // Set up Basket Stock Multiplier Tables
  let tableStartRow = instructionsRow + 2;
  let basketColStart = 1;
  for (let i = 0; i < data.baskets.length; i++) {
    let basketObj = data.baskets[i];
    let bName = basketObj.basket_name;
    let bId = basketObj.basket_id;

    let bracketTitleRange = sheet.getRange(tableStartRow, basketColStart, 1, 2);
    bracketTitleRange.merge();
    bracketTitleRange.setValue(bName);
    bracketTitleRange.setBackground("#BCD4FC");
    bracketTitleRange.setFontWeight("bold");
    bracketTitleRange.setHorizontalAlignment("center");

    // Put the basket_id in the second row, first column of this table
    let basketIdCell = sheet.getRange(tableStartRow - 1, basketColStart);
    basketIdCell.setValue(bId).setFontColor("#FFFFFF"); 

    let stockHeader = sheet.getRange(tableStartRow + 1, basketColStart);
    stockHeader.setValue("Stock")
      .setBackground("#91B9F9")
      .setFontWeight("bold")
      .setHorizontalAlignment("center");

    let multiplierHeader = sheet.getRange(tableStartRow + 1, basketColStart + 1);
    multiplierHeader.setValue("Multiplier")
      .setBackground("#91B9F9")
      .setFontWeight("bold")
      .setHorizontalAlignment("center");

    let mappingHeader = sheet.getRange(tableStartRow + 2, basketColStart + 2);
    mappingHeader.setFontColor("#FFFFFF"); // hide it entirely

    let stData = data.basket_stocks[bName] || [];
    let rowPos = tableStartRow + 2;
    for (let s = 0; s < stData.length; s++) {
      sheet.getRange(rowPos, basketColStart).setValue(stData[s].stock);
      sheet.getRange(rowPos, basketColStart + 1).setValue(stData[s].multiplier);
      sheet.getRange(rowPos, basketColStart + 2).setValue(stData[s].basket_stock_mapping_id).setFontColor("#FFFFFF");
      rowPos++;
    }
    basketColStart += 3;
  }
  sheet.activate();
}

function savePortfolioChanges() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  const name = sheet.getName();
  if (!name.startsWith("Standard Portfolio")) {
    SpreadsheetApp.getUi().alert("Not the correct sheet.");
    return;
  }
  let dataPayload = buildPayloadFromSheet(sheet);

  /***************************************************************************************/
  // var sheet_1 = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Standard Portfolio");
  // var jsonString = JSON.stringify(dataPayload, null, 2);
  // sheet_1.getRange("A50").setValue(jsonString);
  /***************************************************************************************/

  if (!validateMultiplierConstraints(dataPayload)) {
    SpreadsheetApp.getUi().alert("Sum of multipliers != number of stocks in a basket. Fix and retry.");
    return;
  }
  let portfolioId = 1; 
  let url = "http://15.207.59.232:8000/portfolios/"+portfolioId+"/structure/save";
  let resp = UrlFetchApp.fetch(url, {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify(dataPayload),
    muteHttpExceptions: true
  });
  if (resp.getResponseCode() == 200) {
    SpreadsheetApp.getUi().alert("Saved successfully!");
  } else {
    SpreadsheetApp.getUi().alert("Error saving: " + resp.getContentText());
  }
}

function buildPayloadFromSheet(sheet) {
  let brackets = [];
  let baskets = [];
  let allocations = {};
  let bracketStartRow = 5;
  let bracketColName = 1;
  let bracketColMin = 2;
  let bracketColMax = 3;
  let basketStartCol = 4;
  let row = bracketStartRow;

  // Extracting Brackets
  while (true) {
    let brName = String(sheet.getRange(row, bracketColName).getValue() || "").trim();
    let minVal = sheet.getRange(row, bracketColMin).getValue() || 0;
    let maxVal = sheet.getRange(row, bracketColMax).getValue() || 0;
    let bracketId = String(sheet.getRange(row, 50).getValue() || "").trim();
    
    if (!brName && minVal === 0 && maxVal === 0) break; // Stop when fully empty
    brackets.push({
      "bracket_id": bracketId ? bracketId.toString() : "",
      "bracket_name": brName,
      "min_amount": minVal,
      "max_amount": maxVal
      });
    row++;
    if (row > 200) break; // Prevent infinite loops
  }

  // Extract Baskets 
  let basketList = [];
  let col = basketStartCol;
  let firstRow = bracketStartRow - 1;
  let rowAllocStart = bracketStartRow;
  let bracketCount = brackets.length;

  while (col <= 50) {
    let bsName = String(sheet.getRange(firstRow, col).getValue() || "").trim();
    let basketId = String(sheet.getRange(1000, col).getValue() || "").trim();
    let hasNonZeroAllocation = false;
    // Check if any allocation in this column is non-zero
    for (let r = 0; r < bracketCount; r++) {
      let allocVal = sheet.getRange(rowAllocStart + r, col).getValue() || 0;
      if (allocVal !== 0) {
        hasNonZeroAllocation = true;
        break;
      }
    }
    // If the basket name is blank AND allocation is zero, skip this column.
    if (!hasNonZeroAllocation && bsName === "" && basketId === "" && bsName === "Total") {
      col++;
      continue;
    }
    if (bsName !== "" || basketId !== "") {
      basketList.push(bsName ? bsName : "");
      baskets.push({
        "basket_id": basketId,
        "basket_name": bsName,
        "allocation_method": "manual"
        });
    }
    col++;
  }

  // Extract Allocations (keyed by "bracket_id::basket_id")
  let basketCountFinal = baskets.length;
  for (let r = 0; r < bracketCount; r++) {
    let rowIdx = bracketStartRow + r;
    let brId = brackets[r].bracket_id;
    for (let c = 0; c < basketCountFinal; c++) {
      let colIdx = basketStartCol + c;
      let bsId = baskets[c].basket_id;
      let val = sheet.getRange(rowIdx, colIdx).getValue() || 0;
      allocations[brId + "::" + bsId] = val;
    }
  }

  // Extracting Basket Stocks
  let basketStocks = {};
  let stockTablesStart = bracketStartRow + bracketCount + 9;
  let colPos = 1;
  for (let i = 0; i < baskets.length; i++) {
    let bObj = baskets[i];
    let bId = bObj.basket_id; // This is the key
    let tableStartRow = stockTablesStart;
    
    let rowPtr = tableStartRow + 3;
    let stList = [];
    while(true) {
      let sName = String(sheet.getRange(rowPtr+2, colPos).getValue() || "").trim();
      let mult = sheet.getRange(rowPtr+2, colPos+1).getValue() || 0;
      let mappingId = sheet.getRange(rowPtr+2, colPos+2).getValue()
      if (!sName && mult == 0 && !mappingId) {
        break;
      }
      stList.push({
        "stock": sName ? sName : "",
        "multiplier": mult,
        "basket_stock_mapping_id": mappingId
      });
      rowPtr++;
      if (rowPtr > 500) break;
    }
    basketStocks[bId] = stList;
    colPos += 3;
  }
  return {
    brackets: brackets,
    baskets: baskets,
    allocations: allocations,
    basket_stocks: basketStocks
  };
}

function validateMultiplierConstraints(payload) {
  var sheet1 = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Standard Portfolio");
  sheet1.getRange("A50").setValue(JSON.stringify(payload, null, 2));
  let basket_stocks = payload.basket_stocks || {};
  for (let bName in basket_stocks) {
    let list = basket_stocks[bName];
    let countNonBlank = list.filter(x => x.stock && x.stock!="").length;
    let sumMult = list.reduce((acc,x)=>acc+(x.multiplier||0),0);
    if (Math.round(sumMult*100)/100 != countNonBlank) { 
      return false;
    }
  }
  return true;
}

function onEdit(e) {
  const sheet = e.range.getSheet();
  const editedCell = e.range;

  if (sheet.getName() !== "Standard Portfolio") return;

  let bracketStartRow = 5;
  let bracketColName = 1;
  let basketStartCol = 4;

  // Find the edited row and column
  let row = editedCell.getRow();
  let col = editedCell.getColumn();

  // Only trigger if within allocation range
  if (row < bracketStartRow || col < basketStartCol) return;

  // Calculate total for the edited bracket
  let total = 0;
  let lastCol = basketStartCol + sheet.getRange(bracketStartRow - 1, basketStartCol, 1, 50).getLastColumn();
  for (let c = basketStartCol; c < lastCol; c++) {
    let val = sheet.getRange(row, c).getValue() || 0;
    total += val;
  }

  // Update Total column
  let totalColIdx = lastCol + 1;
  let totalCell = sheet.getRange(row, totalColIdx);
  totalCell.setValue(total.toFixed(2));
  if (Math.abs(total - 100) < 0.01) {
    totalCell.setBackground("#C6EFCE");
  } else {
    totalCell.setBackground("#FFC7CE");
  }

  // Auto-correct if total > 100
  if (total > 100) {
    let excess = total - 100;

    // Find "Short Vol" column
    let shortVolCol = -1;
    for (let c = basketStartCol; c < lastCol; c++) {
      let basketName = (sheet.getRange(bracketStartRow - 1, c).getValue() || "").trim();
      if (basketName === "Short Vol") {
        shortVolCol = c;
        break;
      }
    }

    if (shortVolCol !== -1) {
      let currentShortVol = sheet.getRange(row, shortVolCol).getValue() || 0;
      let newShortVol = Math.max(0, currentShortVol - excess);
      sheet.getRange(row, shortVolCol).setValue(newShortVol);
    }

    // Recalculate Total after correction
    let correctedTotal = total - excess;
    totalCell.setValue(correctedTotal.toFixed(2));
    if (Math.abs(correctedTotal - 100) < 0.01) {
      totalCell.setBackground("#C6EFCE");
    } else {
      totalCell.setBackground("#FFC7CE");
    }
  }
}


================================================================================
# File: main.gs
================================================================================

// CREATE MENU
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu("Account Operations")
    .addSubMenu(
      ui.createMenu("Manage Clients & Accounts")
        .addItem("View Clients", "viewClients")
        .addItem("Add Clients", "addClients")
        .addItem("Update Clients", "updateClients")
        .addItem("Delete Clients", "deleteClients")
        .addItem("View Accounts", "viewAccounts")
        .addItem("Update Accounts", "updateAccounts")
        .addItem("Manage Joint Accounts", "manageJointAccounts")
        .addItem("Save", "saveClientChanges")
    )
    .addSubMenu(
      ui.createMenu("Manage Portfolio Structure")
        .addItem("Standard Portfolio", "openStandardPortfolioSheet")
        .addItem("Save", "savePortfolioChanges")
    )
    .addSubMenu(
      ui.createMenu("Manage Manual Inputs")
        .addItem("Input Actual Portfolios", "setupActualPortfolioSheet")
        .addItem("Input Cashflows", "setupCashflowsSheet")
        .addItem("Stock Exceptions", "setupExceptionsSheet")
    )
    .addItem("Manage Brokers & Distributors", "showManagementSidebar")
    .addToUi();

  // Setup log cleanup if it doesn't exist
  const triggers = ScriptApp.getProjectTriggers();
  const hasCleanupTrigger = triggers.some(trigger => 
    trigger.getHandlerFunction() === 'cleanupLogs'
  );
  
  if (!hasCleanupTrigger) {
    createLogCleanupTrigger();
  }
  
  // Clean up logs on open if they're too large
  cleanupLogs();

  viewClients();
  viewAccounts();

}

function saveClientChanges() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  const addSheet = ss.getSheetByName("Add Clients");
  if (addSheet) {
    addClientsSave();
    ss.deleteSheet(addSheet);
  }

  const updateSheet = ss.getSheetByName("Update Clients");
  if (updateSheet) {
    updateClientsSave();
    ss.deleteSheet(updateSheet);
  }

  // Check if "Delete Clients" sheet exists:
  const deleteSheet = ss.getSheetByName("Delete Clients");
  if (deleteSheet) {
    deleteClientsSave();
    ss.deleteSheet(deleteSheet);
  }

  // Check if "Update Account" sheet exists:
  const updateAccountSheet = ss.getSheetByName("Update Accounts");
  if (updateAccountSheet) {
    updateAccountsSave();
    ss.deleteSheet(updateAccountSheet);
  }

  // Check if "Manage Joint Accounts" sheet exists:
  const jointAccountSheet = ss.getSheetByName("Manage Joint Accounts");
  if (jointAccountSheet) {
    saveJointAccountChanges();
    ss.deleteSheet(jointAccountSheet);
  }

  viewClients();
  viewAccounts();
}

function saveManualInputs() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  const actualPortfolioSheet = ss.getSheetByName("Actual Portfolio Input")
  if (actualPortfolioSheet) {
    saveActualPortfolio();
    ss.deleteSheet(actualPortfolioSheet);
  }

  const exceptionsSheet = ss.getSheetByName("Exceptions")
  if (exceptionsSheet) {
    saveExceptions();
    ss.deleteSheet(exceptionsSheet);
  }

  const cashflowsSheet = ss.getSheetByName("Cashflows Input")
  if (cashflowsSheet) {
    saveCashflows();
    ss.deleteSheet(saveCashflows);
  }
}


================================================================================
# File: client.gs
================================================================================

function viewClients() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  try {
    // Log the start of creating/clearing the read-only sheet
    logAction(
      "Create Sheet",
      "View Clients",
      "",
      "",
      "",
      "Started",
      "Attempting to create or clear the 'Client Details' sheet",
      "INFO"
    );

    // 1) Create or clear the "Client Details" sheet
    let sheetName = "Client Details";
    let sheet = ss.getSheetByName(sheetName);

    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
      logAction(
        "Create Sheet",
        "Client Details",
        "",
        "",
        "",
        "Success",
        "Created new 'Client Details' sheet",
        "INFO"
      );
    } else {
      sheet.clear();
      logAction(
        "Clear Sheet",
        "Client Details",
        "",
        "",
        "",
        "Success",
        "Cleared existing 'Client Details' sheet",
        "INFO"
      );
    }

    // 2) Add a read-only notice at the top (merge columns as needed)
    const totalColumns = 19; // Adjust if you have fewer or more columns
    sheet
      .getRange(1, 1, 1, totalColumns)
      .merge()
      .setValue("Client Details Sheet: [Read Only]")
      .setBackground("#a4c2f4")
      .setFontColor("#000000")
      .setFontWeight("bold")
      .setHorizontalAlignment("center");

    // 3) Create column headers in the second row
    const headers = [
      "Client ID",
      "Client Name",
      "Account ID",
      "Broker Name",
      "Broker Code",
      "Broker Password",
      "PAN No.",
      "Country Code",
      "Phone No.",
      "Email ID",
      "Address",
      "Account Start Date",
      "Distributor",
      "Onboard Status",
      "Type",
      "Alias Name",
      "Alias Phone No.",
      "Alias Address",
      "Created At"
    ];

    sheet
      .getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#3c78d8")
      .setFontColor("#FFFFFF");

    sheet.setFrozenRows(2);

    // Set a uniform width for all columns so they are evenly spaced
    sheet.setColumnWidths(1, headers.length, 130);

    // 4) Fetch client data from the endpoint
    const endpoint = "http://15.207.59.232:8000/clients/list"; // Replace if needed
    let clientData = [];

    try {
      logAction(
        "Fetch Data",
        "Clients",
        "",
        "",
        "",
        "Started",
        "Fetching client data from " + endpoint,
        "INFO"
      );

      const response = UrlFetchApp.fetch(endpoint);
      const statusCode = response.getResponseCode();

      if (statusCode === 200) {
        clientData = JSON.parse(response.getContentText());
        logAction(
          "Fetch Data",
          "Clients",
          "",
          "",
          "",
          "Success",
          `Fetched ${clientData.length} clients from ${endpoint}`,
          "INFO"
        );
      } else {
        logAction(
          "Fetch Data",
          "Clients",
          "",
          "",
          "",
          "Failed",
          "Status code: " + statusCode,
          "ERROR"
        );
        ui.alert("Failed to fetch client data. Status code: " + statusCode);
      }
    } catch (error) {
      logError("viewClients:FetchData", error);
      ui.alert("Error fetching client data: " + error.message);
    }

    // 5) Populate the sheet if we have data
    if (clientData.length > 0) {
      const rowData = clientData.map(client => [
        client.client_id || "",
        client.client_name || "",
        client.account_id || "",
        client.broker_name || "",
        client.broker_code || "",
        client.broker_passwd || "",
        client.pan_no || "",
        client.country_code || "",
        client.phone_no || "",
        client.email_id || "",
        client.addr || "",
        client.acc_start_date || "",
        client.distributor_name || "",
        client.onboard_status || "",
        client.type || "",
        client.alias_name || "",
        client.alias_phone_no || "",
        client.alias_addr || "",
        client.created_at || ""
      ]);

      sheet
        .getRange(3, 1, rowData.length, headers.length)
        .setValues(rowData);

      logAction(
        "Populate Sheet",
        "Client Details",
        "",
        "",
        "",
        "Success",
        `Populated ${rowData.length} rows with client data`,
        "INFO"
      );
    } else {
      logAction(
        "Populate Sheet",
        "Client Details",
        "",
        "",
        "",
        "Success",
        "No client data found to display",
        "INFO"
      );
    }

    // 6) Color alternate rows (white for first row, #F3F3F3 for second, etc.)
    const startRow = 3; // first row of data
    const numRows = sheet.getLastRow() - (startRow - 1);
    for (let i = 0; i < numRows; i++) {
      // sheet row index
      const rowIndex = startRow + i;
      // even-numbered block => #FFFFFF, odd => #F3F3F3
      if (i % 2 === 0) {
        sheet
          .getRange(rowIndex, 1, 1, headers.length)
          .setBackground("#FFFFFF");
      } else {
        sheet
          .getRange(rowIndex, 1, 1, headers.length)
          .setBackground("#F8F8F8");
      }
    }

    // 7) Make all data rows read-only by protecting them
    try {
      const protectionRange = sheet.getRange(
        startRow,
        1,
        sheet.getMaxRows() - 2,
        headers.length
      );
      const protection = protectionRange.protect();
      protection.setDescription("Protected range for read-only sheet");

      if (protection.canDomainEdit()) {
        protection.setDomainEdit(false);
      }

      // Remove existing editors to ensure it's fully read-only
      const editors = protection.getEditors();
      if (editors && editors.length > 0) {
        protection.removeEditors(editors);
      }
    } catch (protError) {
      // We'll log the protection error, but not throw
      logAction(
        "Set Protection",
        "Client Details",
        "",
        "",
        "",
        "Failed",
        "Unable to protect sheet range. " + protError.message,
        "ERROR"
      );
    }

    // Notify user that the sheet is ready
    ui.alert(
      "Client Details Sheet Ready",
      "This is a read-only sheet showing all clients.",
      ui.ButtonSet.OK
    );

    logAction(
      "Create Sheet",
      "View Clients",
      "",
      "",
      "",
      "Completed",
      "'Client Details' sheet successfully populated",
      "INFO"
    );

    sheet.activate();
  } catch (error) {
    // Log and notify major errors
    logError("viewClients", error);
    ui.alert(
      "Error creating or populating the 'Client Details' sheet: " + error.message
    );
  }
}


function addClients() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  try {
    logAction("Create Sheet", "Clients", "", "", "", "Started", "Initializing Add Clients sheet", "INFO");

    let sheet = ss.getSheetByName("Add Clients");
    if (!sheet) {
      sheet = ss.insertSheet("Add Clients");
      logAction("Create Sheet", "Clients", "", "", "", "Success", "Created new 'Add Clients' sheet", "INFO");
    } else {
      sheet.clear();
      logAction("Create Sheet", "Clients", "", "", "", "Success", "Cleared existing 'Add Clients' sheet", "INFO");
    }

    // Instructions and Headers
    sheet
      .getRange(1, 1, 1, 15)
      .merge()
      .setValue(
        "Instructions: Fields 'Client Name', 'Broker Name' and 'Pan No.' are required.\n" +
        "Dates in YYYY-MM-DD format.\nUse dropdown for 'Broker Name' and 'Distributor'."
      )
      .setBackground("#AFE1AF")
      .setFontColor("#000000")
      .setFontWeight("bold");

    // Headers (15 columns)
    const headers = [
      "Client Name", 
      "Broker Name", 
      "Broker Code", 
      "Broker Password", 
      "Email ID",
      "Pan No.", 
      "Country Code", 
      "Phone No.", 
      "Address", 
      "Account Start Date",
      "Distributor", 
      "Alias Name", 
      "Alias Phone No.", 
      "Alias Address",
      "Type"
    ];

    sheet
      .getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#379d37")
      .setFontColor("#FFFFFF");
    sheet.setFrozenRows(2);
    sheet.setColumnWidths(1, headers.length, 150);

    // Fetch Brokers and Distributors
    let brokers = [];
    let distributors = [];
    try {
      brokers = getBrokersList();
      logAction("Fetch Data", "Brokers", "", "", "", "Success", `Fetched ${brokers.length} brokers`, "INFO");
    } catch (error) {
      logError("getBrokersList", error);
      ui.alert("Error fetching brokers: " + error.message);
    }

    try {
      distributors = getDistributorsList();
      logAction("Fetch Data", "Distributors", "", "", "", "Success", `Fetched ${distributors.length} distributors`, "INFO");
    } catch (error) {
      logError("getDistributorsList", error);
      ui.alert("Error fetching distributors: " + error.message);
    }

    // Apply Dropdowns for Brokers
    if (brokers.length > 0) {
      const brokerRange = sheet.getRange(3, 2, 1000); // Column B
      const brokerRule = SpreadsheetApp.newDataValidation()
        .requireValueInList(brokers, true)
        .setAllowInvalid(false)
        .build();
      brokerRange.setDataValidation(brokerRule);
    }

    // Apply Dropdowns for Distributors
    if (distributors.length > 0) {
      const distributorRange = sheet.getRange(3, 11, 1000); // Column K=11, L=12, etc.
      const distributorRule = SpreadsheetApp.newDataValidation()
        .requireValueInList(distributors, true)
        .setAllowInvalid(false)
        .build();
      distributorRange.setDataValidation(distributorRule);
    }

    ui.alert(
      "Add Client sheet created",
      "Fill in details. Use 'Save Changes' when done.",
      ui.ButtonSet.OK
    );

    logAction("Create Sheet", "Clients", "", "", "", "Completed", "Add Clients sheet setup complete", "INFO");
    sheet.activate();
  } catch (error) {
    logError("addClients", error);
    ui.alert("Error creating Add Clients sheet: " + error.message);
  }
}

function addClientsSave() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetName = "Add Clients";
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    SpreadsheetApp.getUi().alert("Sheet 'Add Clients' not found.");
    return;
  }

  // Read all rows below the header (assuming header is in row 2)
  const lastRow = sheet.getLastRow();
  if (lastRow < 3) {
    SpreadsheetApp.getUi().alert("No data found on 'Add Clients' sheet.");
    return;
  }

  // For example, read 16 columns as in your existing code
  const dataRange = sheet.getRange(3, 1, lastRow - 2, 16);
  const data = dataRange.getValues();

  // We'll store valid vs. invalid
  const validRows = [];
  const invalidRows = [];

  // If you keep a brokers list:
  let brokers = [];
  try {
    brokers = getBrokersList(); // Your function that fetches broker names
    logAction("Fetch Data", "Brokers", "", "", "", "Success", `Fetched ${brokers.length} brokers`, "INFO");
  } catch (error) {
    logError("getBrokersList", error);
    SpreadsheetApp.getUi().alert("Error fetching brokers: " + error.message);
  }

  // Simple PAN regex
  const panRegex = /^[A-Z]{5}[0-9]{4}[A-Z]{1}$/;

  logAction("Save Changes", "Clients", "", "", "", "Started", "Validating client data", "INFO");

  data.forEach((row, idx) => {
    // Using your 16 columns from the example
    const [
      clientName, brokerName, brokerCode, brokerPasswd, emailId,
      panNo, countryCode, phoneNo, addr, accStartDate,
      distributorName, aliasName, aliasPhoneNo, aliasAddr, type
    ] = row.map(cell => cell ? cell.toString().trim() : '');

    // Validate
    let errors = [];

    // Required Fields
    if (!clientName) errors.push("Client Name is required.");
    if (!brokerName || !brokers.includes(brokerName)) errors.push("Valid Broker Name is required.");
    if (!panNo || !panRegex.test(panNo)) errors.push("PAN No. is invalid.");

    // Numeric checks
    const numericPhoneNo = phoneNo ? phoneNo.toString() : null;
    const numericCountryCode = countryCode ? countryCode.toString() : null;
    if (numericPhoneNo !== null && (isNaN(numericPhoneNo) || numericPhoneNo.length > 15)) {
      errors.push("Phone No. must be numeric and 15 digits.");
    }
    if (numericCountryCode !== null && (isNaN(numericCountryCode) || numericCountryCode.length > 3)) {
      errors.push("Country Code must be numeric and 3 digits.");
    }

    // Date parse (if needed)
    let formattedDate = "";
    if (accStartDate) {
      try {
        formattedDate = formatDate(accStartDate); 
      } catch (e) {
        errors.push(`Invalid Date: ${e.message}`);
      }
    }

    if (errors.length === 0) {
      // Valid row
      validRows.push({
        client_name: clientName,
        broker_name: brokerName,
        broker_code: brokerCode,
        broker_passwd: brokerPasswd,
        email_id: emailId,
        pan_no: panNo,
        country_code: numericCountryCode,
        phone_no: numericPhoneNo,
        addr: addr,
        acc_start_date: formattedDate,
        distributor_name: distributorName,
        alias_name: aliasName,
        alias_phone_no: aliasPhoneNo,
        alias_addr: aliasAddr,
        type: type
      });
      logAction("Validation", "Client", clientName, panNo, brokerName, "Valid", "Client passed validation", "INFO");
    } else {
      // Invalid row
      invalidRows.push({ row: idx + 3, errors });
      logAction("Validation", "Client", clientName, panNo, brokerName, "Invalid", `Row ${idx + 3} errors: ${errors.join("; ")}`, "WARNING");
    }
  });

  // If any invalid rows, show an alert and stop
  if (invalidRows.length > 0) {
    let errorMsg = "Validation Errors:\n";
    invalidRows.forEach(err => {
      errorMsg += `Row ${err.row}: ${err.errors.join("; ")}\n`;
    });
    SpreadsheetApp.getUi().alert(errorMsg);
    return;
  }

  // If no valid rows, nothing to send
  if (validRows.length === 0) {
    SpreadsheetApp.getUi().alert("No valid data to submit.");
    return;
  }

  // Log we are about to send
  logAction("Validation", "Client", "", "", "", "Valid", JSON.stringify(validRows), "INFO");

  // Send to backend
  const url = "http://15.207.59.232:8000/clients/add"; 
  const options = {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify(validRows),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const statusCode = response.getResponseCode();
    const contentText = response.getContentText();

    // Log the raw response
    logAction("Add Clients", "API Response", "", "", "", 
              statusCode === 200 ? "Success" : "Failed",
              `Response: ${contentText}`, 
              statusCode === 200 ? "INFO" : "ERROR");

    if (statusCode !== 200) {
      SpreadsheetApp.getUi().alert("Error adding clients: " + contentText);
      return;
    }

    // Parse partial success
    const resultObj = JSON.parse(contentText);
    // resultObj => { total_rows, processed_rows, results: [ { row_index, status, detail, client_id } ... ] }

    // We'll log each row result
    let failCount = 0;
    let failMessages = [];
    let successCount = 0;

    resultObj.results.forEach(r => {
      if (r.status === "success") {
        successCount++;
        logAction("Create Clients", "Client", "", "", "", 
                  "Success", `Row ${r.row_index} - ${r.detail}`, 
                  "INFO");
      } else {
        failCount++;
        failMessages.push(`Row ${r.row_index} - ${r.detail}`);
        logAction("Create Clients", "Client", "", "", "", 
                  "Failed", `Row ${r.row_index} - ${r.detail}`, 
                  "ERROR");
      }
    });

    // Show summary
    const msg = `Clients Creation Summary:
    Total Rows Sent: ${resultObj.total_rows}
    Processed (Success): ${resultObj.processed_rows}
    Failures: ${failCount}
    ${failCount > 0 ? "Errors:\n" + failMessages.join("\n") : ""}`;

    SpreadsheetApp.getUi().alert(msg);

  } catch (error) {
    logError("addClientsSave", error, { validRows });
    SpreadsheetApp.getUi().alert("Error communicating with backend: " + error.message);
  }
}


function formatDate(dateStr) {
  if (!dateStr) return null;

  const parts = dateStr.split(' ');
  const [dayOfWeek, month, day, year] = parts;
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const monthIndex = months.indexOf(month) + 1; // 1-based index
  return `${year}-${monthIndex.toString().padStart(2, '0')}-${day.padStart(2, '0')}`;
}


function updateClients() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  try {
    logAction(
      "Create Sheet",
      "Update Clients",
      "",
      "",
      "",
      "Started",
      "Attempting to create or clear the 'Update Clients' sheet",
      "INFO"
    );

    // Create or clear existing sheet
    let sheet = ss.getSheetByName("Update Clients");
    if (!sheet) {
      sheet = ss.insertSheet("Update Clients");
      logAction(
        "Create Sheet",
        "Update Clients",
        "",
        "",
        "",
        "Success",
        "Created new 'Update Clients' sheet",
        "INFO"
      );
    } else {
      sheet.clear();
      logAction(
        "Clear Sheet",
        "Update Clients",
        "",
        "",
        "",
        "Success",
        "Cleared existing 'Update Clients' sheet",
        "INFO"
      );
    }

    // Header row with instructions
    sheet.getRange(1, 1, 1, 16)
      .merge()
      .setValue(
        "Instructions: Check rows to update. Editable fields: Broker Name, Broker Code, Distributor, Country Code, Phone, Email, Address, Account Start Date, Alias Fields.\n" +
        "Gray columns are read-only. Use dropdowns where available.\n" +
        "When done, click 'Save Changes' to send updates to the server."
      )
      .setBackground("#F4B084")
      .setFontColor("#000000")
      .setFontWeight("bold");

    // Define table headers
    const headers = [
      "Select",            // A
      "Client ID",         // B (read-only)
      "Client Name",       // C (read-only)
      "Broker Name",       // D
      "Broker Code",       // E
      "Distributor",       // F
      "PAN No.",           // G (read-only)
      "Country Code",      // H
      "Phone No.",         // I
      "Email ID",          // J
      "Address",           // K
      "Account Start Date",// L
      "Alias Name",        // M
      "Alias Phone No.",   // N
      "Alias Address",     // O
      "Type"               // P (read-only or editable as needed)
    ];
    sheet.getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#d67332")
      .setFontColor("#FFFFFF");

    sheet.setFrozenRows(2);
    sheet.setColumnWidths(1, headers.length, 140);

    // Add a checkbox column (Column A)
    const checkboxRange = sheet.getRange(3, 1, 1000);
    const checkboxRule = SpreadsheetApp.newDataValidation()
      .requireCheckbox()
      .build();
    checkboxRange.setDataValidation(checkboxRule);

    // Fetch client data from the backend
    let clientData = [];
    const endpoint = "http://15.207.59.232:8000/clients/list";

    try {
      const response = UrlFetchApp.fetch(endpoint);
      // Use handleApiResponse to log request/response if you like:
      //   handleApiResponse(response, "Fetch Clients");
      // But if you only want to parse, do so directly:
      clientData = JSON.parse(response.getContentText());

      logAction(
        "Fetch Data",
        "Clients",
        "",
        "",
        "",
        "Success",
        `Fetched ${clientData.length} clients from ${endpoint}`,
        "INFO"
      );
    } catch (error) {
      logError("updateClients:FetchClients", error);
      ui.alert("Error fetching client data: " + error.message);
    }

    // Populate sheet with client data
    if (clientData.length > 0) {
      // Map each client to its row
      const rowData = clientData.map(client => [
        false,                            // A (Select checkbox)
        client.client_id || "",           // B
        client.client_name || "",         // C
        client.broker_name || "",         // D
        client.broker_code || "",         // E
        client.distributor_name || "",    // F
        client.pan_no || "",             // G
        client.country_code || "",        // H
        client.phone_no || "",           // I
        client.email_id || "",           // J
        client.addr || "",               // K
        client.acc_start_date || "",      // L
        client.alias_name || "",          // M
        client.alias_phone_no || "",      // N
        client.alias_addr || "",          // O
        client.type || ""                 // P
      ]);
      sheet.getRange(3, 1, rowData.length, rowData[0].length).setValues(rowData);
    }

    /*
      PROTECT READ-ONLY COLUMNS
      Adjust as needed. The example sets B=2, C=3, G=7, and P=16 as read-only.
    */
    const readOnlyColumns = [2]; // B, C, G, P
    readOnlyColumns.forEach(colIdx => {
      const rangeToProtect = sheet.getRange(3, colIdx, sheet.getMaxRows() - 2);
      rangeToProtect.setBackground("#F3F3F3");

      const protection = rangeToProtect.protect();
      protection.setDescription(`Protected column ${colIdx} for read-only fields`);

      if (protection.canDomainEdit()) {
        protection.setDomainEdit(false);
      }

      const editors = protection.getEditors();
      if (editors && editors.length > 0) {
        protection.removeEditors(editors);
      }
    });

    let brokers = [];
    let distributors = [];
    try {
      brokers = getBrokersList();
      logAction("Fetch Data", "Brokers", "", "", "", "Success", `Fetched ${brokers.length} brokers`, "INFO");
    } catch (error) {
      logError("getBrokersList", error);
      ui.alert("Error fetching brokers: " + error.message);
    }

    try {
      distributors = getDistributorsList();
      logAction("Fetch Data", "Distributors", "", "", "", "Success", `Fetched ${distributors.length} distributors`, "INFO");
    } catch (error) {
      logError("getDistributorsList", error);
      ui.alert("Error fetching distributors: " + error.message);
    }

    // Apply Dropdowns for Brokers
    if (brokers.length > 0) {
      const brokerRange = sheet.getRange(3, 4, 1000);
      const brokerRule = SpreadsheetApp.newDataValidation()
        .requireValueInList(brokers, true)
        .setAllowInvalid(false)
        .build();
      brokerRange.setDataValidation(brokerRule);
    }

    // Apply Dropdowns for Distributors
    if (distributors.length > 0) {
      const distributorRange = sheet.getRange(3, 6, 1000);
      const distributorRule = SpreadsheetApp.newDataValidation()
        .requireValueInList(distributors, true)
        .setAllowInvalid(false)
        .build();
      distributorRange.setDataValidation(distributorRule);
    }

    ui.alert(
      "Update Client sheet ready",
      "Check rows to update, make changes, then click 'Save Changes' to send updates to the server.",
      ui.ButtonSet.OK
    );
    logAction(
      "Create Sheet",
      "Update Clients",
      "",
      "",
      "",
      "Completed",
      "'Update Clients' sheet successfully set up",
      "INFO"
    );
    sheet.activate();
  } catch (error) {
    logError("updateClients", error);
    ui.alert("Error creating or populating the 'Update Clients' sheet: " + error.message);
  }
}

function updateClientsSave() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetName = "Update Clients";
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    SpreadsheetApp.getUi().alert("Sheet 'Update Clients' not found.");
    logAction(
      "Update Clients",
      "Sheet",
      "",
      "",
      "",
      "Failed",
      "No 'Update Clients' sheet found",
      "ERROR"
    );
    return;
  }

  const lastRow = sheet.getLastRow();
  if (lastRow < 3) {
    ss.toast("No client rows found to update.", "Info", 3);
    return;
  }

  // Suppose columns are the same as your example,
  // but you have a checkbox in col A, and client_id in col B
  // We'll read 16 columns
  const dataRange = sheet.getRange(3, 1, lastRow - 2, 16);
  const data = dataRange.getValues();

  const updates = [];
  const noChangeMessages = [];

  // We'll do a simple approach: if row[0] == true, we attempt to update.
  // We skip advanced validations here, but you can add them if needed
  data.forEach((row, idx) => {
    if (row[0] === true) { // the checkbox in column A
      // Build a payload object
      const updatePayload = {
        client_id: row[1],              // B
        client_name: row[2],           // C
        broker_name: row[3],           // D
        broker_code: row[4],           // E
        distributor_name: row[5],      // F
        pan_no: row[6],                // G
        country_code: row[7] ? String(row[7]) : "",
        phone_no: row[8] ? String(row[8]) : "",
        email_id: row[9],
        addr: row[10],
        acc_start_date: row[11],
        alias_name: row[12],
        alias_phone_no: row[13] ? String(row[13]) : "",
        alias_addr: row[14],
        type: row[15]
      };

      // You might remove empty fields if you only want partial updates
      // For example:
      // Object.entries(...).filter(([k,v]) => v !== "" && v !== null && v!==undefined)
      // ...
      // But well keep it simple here

      // if client_id is missing, well rely on backend partial logic
      updates.push(updatePayload);
    }
  });

  if (updates.length === 0) {
    ss.toast("No selected rows with changes found.", "Info", 3);
    return;
  }

  logAction(
    "Update Clients",
    "Sheet",
    "",
    "",
    "",
    "Sending",
    `Sending ${updates.length} updates to the server`,
    "INFO"
  );

  const url = "http://15.207.59.232:8000/clients/update";
  const options = {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify(updates),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const code = response.getResponseCode();
    const contentText = response.getContentText();

    // Log raw response
    logAction(
      "Update Clients",
      "API Response",
      "",
      "",
      "",
      code === 200 ? "Success" : "Failed",
      `Response: ${contentText}`,
      code === 200 ? "INFO" : "ERROR"
    );

    if (code !== 200) {
      SpreadsheetApp.getUi().alert("Error updating clients: " + contentText);
      return;
    }

    // Partial success results
    const resultObj = JSON.parse(contentText);
    // { total_rows, processed_rows, results: [ {row_index, status, detail, client_id}, ... ] }

    let failCount = 0;
    let failMessages = [];
    let successCount = 0;

    resultObj.results.forEach(r => {
      if (r.status === "success") {
        successCount++;
        logAction("Update Clients", "Client", r.client_id, "", "", 
                  "Success", `Row ${r.row_index} - ${r.detail}`, "INFO");
      } else {
        failCount++;
        failMessages.push(`Row ${r.row_index} - ${r.detail}`);
        logAction("Update Clients", "Client", r.client_id, "", "", 
                  "Failed", `Row ${r.row_index} - ${r.detail}`, "ERROR");
      }
    });

    const msg = `Bulk Update Completed:
    Total Rows: ${resultObj.total_rows}
    Success: ${resultObj.processed_rows}
    Failures: ${failCount}
    ${failCount > 0 ? "Errors:\n" + failMessages.join("\n") : ""}`;

    SpreadsheetApp.getUi().alert(msg);

    ss.toast("Client updates applied. See logs for details.", "Success", 5);

  } catch (error) {
    logError("updateClientsSave", error, { updates });
    ss.toast("Client update failed: " + error.message, "Error", 5);
  }
}

function deleteClients() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  try {
    logAction(
      "Create Sheet",
      "Delete Clients",
      "",
      "",
      "",
      "Started",
      "Attempting to create or clear the 'Delete Clients' sheet",
      "INFO"
    );

    // Create or clear existing "Delete Clients" sheet
    let sheet = ss.getSheetByName("Delete Clients");
    if (!sheet) {
      sheet = ss.insertSheet("Delete Clients");
      logAction(
        "Create Sheet",
        "Delete Clients",
        "",
        "",
        "",
        "Success",
        "Created new 'Delete Clients' sheet",
        "INFO"
      );
    } else {
      sheet.clear();
      logAction(
        "Clear Sheet",
        "Delete Clients",
        "",
        "",
        "",
        "Success",
        "Cleared existing 'Delete Clients' sheet",
        "INFO"
      );
    }

    // Row 1: Instructions (mirroring the 'Update Clients' design style)
    sheet
      .getRange(1, 1, 1, 8)
      .merge()
      .setValue(
        "Instructions: Check rows to delete. Gray columns are read-only. " +
        "When done, click 'Save Deletions' to remove these clients from the server."
      )
      .setBackground("#C06060")
      .setFontColor("#000000")
      .setFontWeight("bold");

    // Row 2: Column headers (only showing requested columns)
    const headers = [
      "Select",            // A
      "Client ID",         // B (read-only)
      "Client Name",       // C (read-only)
      "Broker Name",       // D
      "Broker Code",       // E
      "PAN No.",           // F (read-only)
      "Distributor",       // G
      "Account Start Date" // H
    ];
    sheet
      .getRange(2, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight("bold")
      .setBackground("#800000")
      .setFontColor("#FFFFFF");

    sheet.setFrozenRows(2);
    sheet.setColumnWidths(1, headers.length, 140);

    // Add a checkbox column (Column A)
    const checkboxRange = sheet.getRange(3, 1, 1000);
    const checkboxRule = SpreadsheetApp.newDataValidation().requireCheckbox().build();
    checkboxRange.setDataValidation(checkboxRule);

    // Fetch client data from the backend
    let clientData = [];
    const endpoint = "http://15.207.59.232:8000/clients/list";
    try {
      const response = UrlFetchApp.fetch(endpoint);
      clientData = JSON.parse(response.getContentText());
      logAction(
        "Fetch Data",
        "Clients",
        "",
        "",
        "",
        "Success",
        `Fetched ${clientData.length} clients from ${endpoint}`,
        "INFO"
      );
    } catch (error) {
      logError("deleteClients:FetchClients", error);
      ui.alert("Error fetching client data: " + error.message);
    }

    // Populate sheet with requested columns
    if (clientData.length > 0) {
      const rowData = clientData.map((client) => [
        false,                             // A (Select checkbox)
        client.client_id || "",            // B
        client.client_name || "",          // C
        client.broker_name || "",          // D
        client.broker_code || "",          // E
        client.pan_no || "",               // F
        client.distributor_name || "",     // G
        client.acc_start_date || ""        // H
      ]);
      sheet.getRange(3, 1, rowData.length, headers.length).setValues(rowData);
    }

    /**
     * Protect read-only columns: 
     *   B=2 (Client ID), C=3 (Client Name), F=6 (PAN No.)
     * Adjust if you'd like to change which columns are locked.
     */
    const readOnlyCols = [2, 3, 6]; 
    readOnlyCols.forEach((colIdx) => {
      const rangeToProtect = sheet.getRange(3, colIdx, sheet.getMaxRows() - 2);
      rangeToProtect.setBackground("#F3F3F3");

      const protection = rangeToProtect.protect();
      protection.setDescription(`Protected column ${colIdx} for read-only fields`);

      if (protection.canDomainEdit()) {
        protection.setDomainEdit(false);
      }

      const editors = protection.getEditors();
      if (editors && editors.length > 0) {
        protection.removeEditors(editors);
      }
    });

    ui.alert(
      "Delete Clients sheet ready",
      "Check rows to delete, then click 'Save Deletions' to remove them from the server.",
      ui.ButtonSet.OK
    );
    logAction(
      "Create Sheet",
      "Delete Clients",
      "",
      "",
      "",
      "Completed",
      "'Delete Clients' sheet successfully set up",
      "INFO"
    );
    sheet.activate();
  } catch (error) {
    logError("deleteClients", error);
    ui.alert("Error creating or populating the 'Delete Clients' sheet: " + error.message);
  }
}

function deleteClientsSave() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetName = "Delete Clients";
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    SpreadsheetApp.getUi().alert("Sheet 'Delete Clients' not found.");
    return;
  }

  const lastRow = sheet.getLastRow();
  if (lastRow < 3) {
    ss.toast("No clients in the sheet to check.", "Info", 3);
    return;
  }

  // Suppose we read 8 columns, with a checkbox in col A and client_id in col B
  const dataRange = sheet.getRange(3, 1, lastRow - 2, 8);
  const data = dataRange.getValues();

  // We'll build a simple array of client_ids
  const clientIdsToDelete = [];
  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    if (row[0] === true) { // checkbox
      const cid = row[1] ? String(row[1]) : "";
      if (cid) clientIdsToDelete.push(cid);
    }
  }

  if (!clientIdsToDelete.length) {
    ss.toast("No clients selected for deletion.", "Info", 3);
    return;
  }

  // Confirm
  const ui = SpreadsheetApp.getUi();
  const confirmation = ui.alert(
    "Confirm Deletion",
    `Are you sure you want to delete ${clientIdsToDelete.length} client(s)? This action is irreversible.`,
    ui.ButtonSet.OK_CANCEL
  );
  if (confirmation !== ui.Button.OK) {
    ss.toast("Deletion canceled.", "Info", 3);
    return;
  }

  // Log the deletion request
  logAction(
    "Delete Clients",
    "Multiple",
    "",
    "",
    "",
    "Initiated",
    `Requested deletion of ${clientIdsToDelete.length} client(s).`,
    "INFO"
  );

  // Partial success endpoint
  const url = "http://15.207.59.232:8000/clients/delete";
  const options = {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify(clientIdsToDelete),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const code = response.getResponseCode();
    const contentText = response.getContentText();

    logAction(
      "Delete Clients",
      "API Response",
      "",
      "",
      "",
      code === 200 ? "Success" : "Failed",
      `Response: ${contentText}`,
      code === 200 ? "INFO" : "ERROR"
    );

    if (code !== 200) {
      SpreadsheetApp.getUi().alert("Error deleting clients: " + contentText);
      return;
    }

    // Parse partial success
    const resultObj = JSON.parse(contentText);
    // { total_rows, processed_rows, results: [ {row_index, status, detail, client_id}, ... ] }

    let failCount = 0;
    let failMessages = [];
    let successCount = 0;

    resultObj.results.forEach(r => {
      if (r.status === "success") {
        successCount++;
        logAction("Delete Clients", "Client", r.client_id, "", "", 
                  "Success", `Row ${r.row_index} - ${r.detail}`, "INFO");
      } else {
        failCount++;
        failMessages.push(`Row ${r.row_index} - ${r.detail}`);
        logAction("Delete Clients", "Client", r.client_id, "", "", 
                  "Failed", `Row ${r.row_index} - ${r.detail}`, "ERROR");
      }
    });

    const msg = `Bulk Delete Completed:
    Total: ${resultObj.total_rows}
    Success: ${resultObj.processed_rows}
    Failures: ${failCount}
    ${failCount > 0 ? "Errors:\n" + failMessages.join("\n") : ""}`;

    SpreadsheetApp.getUi().alert(msg);
    ss.toast("Client deletion request processed. See logs for details.", "Success", 5);

  } catch (error) {
    logError("deleteClientsSave", error, { clientIdsToDelete });
    ss.toast("Client deletion failed: " + error.message, "Error", 5);
  }
}



================================================================================
# File: brokerDistributors.gs
================================================================================

function showManagementSidebar() {
  const html = HtmlService.createTemplateFromFile('brokerDistributorsHTML')
    .evaluate()
    .setTitle('Manage Brokers and Distributors')
    .setSandboxMode(HtmlService.SandboxMode.IFRAME);
  SpreadsheetApp.getUi().showSidebar(html);
}

function getItemsFromBackend(section) {
  if (section === "Brokers") return getBrokersList();
  else if (section === "Distributors") return getDistributorsList();
  throw new Error("Unknown section: " + section);
}

function getBrokersList() {
  const url = "http://15.207.59.232:8000/brokers";
  const options = { muteHttpExceptions: true, headers: { "Accept": "application/json" } };
  let resp = UrlFetchApp.fetch(url, options);
  if (resp.getResponseCode() === 200) {
    let data = JSON.parse(resp.getContentText());
    return data.map(b => b.broker_name);
  }
  throw new Error("Failed to fetch brokers: " + resp.getContentText());
}

function getDistributorsList() {
  const url = "http://15.207.59.232:8000/distributors";
  const options = { muteHttpExceptions: true, headers: { "Accept": "application/json" } };
  let resp = UrlFetchApp.fetch(url, options);
  if (resp.getResponseCode() === 200) {
    let data = JSON.parse(resp.getContentText());
    return data.map(d => d.name);
  }
  throw new Error("Failed to fetch distributors: " + resp.getContentText());
}

function addNewItemToBackend(section, newItem) {
  let endpoint;
  if (section === "Brokers") endpoint = "brokers/add";
  else if (section === "Distributors") endpoint = "distributors/add";
  else throw new Error("Unknown section: " + section);
  
  const url = "http://15.207.59.232:8000/" + endpoint;
  const options = {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify({ value: newItem }),
    muteHttpExceptions: true
  };
  let resp = UrlFetchApp.fetch(url, options);
  if (resp.getResponseCode() !== 200) throw new Error(resp.getContentText());
}

function updateItemInBackend(section, oldItem, newItem) {
  let endpoint;
  if (section === "Brokers") endpoint = "brokers/update";
  else if (section === "Distributors") endpoint = "distributors/update";
  else throw new Error("Unknown section: " + section);
  
  const url = "http://15.207.59.232:8000/" + endpoint;
  const options = {
    method: "put",
    contentType: "application/json",
    payload: JSON.stringify({ old_value: oldItem, new_value: newItem }),
    muteHttpExceptions: true
  };
  let resp = UrlFetchApp.fetch(url, options);
  if (resp.getResponseCode() !== 200) throw new Error(resp.getContentText());
}

function deleteItemFromBackend(section, item) {
  let endpoint;
  if (section === "Brokers") endpoint = "brokers/delete";
  else if (section === "Distributors") endpoint = "distributors/delete";
  else throw new Error("Unknown section: " + section);
  
  const url = "http://15.207.59.232:8000/" + endpoint;
  const options = {
    method: "delete",
    contentType: "application/json",
    payload: JSON.stringify({ value: item }),
    muteHttpExceptions: true
  };
  let resp = UrlFetchApp.fetch(url, options);
  if (resp.getResponseCode() !== 200) throw new Error(resp.getContentText());
}

================================================================================
# Summary: Processed 9 Python files
# End of combined codebase
